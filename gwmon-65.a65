;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Glitch Works Monitor for 6502 and Compatibles
;
;Customized for Glitch Works R65X1Q SBC. This is development
;code and expects the R65X1Q SBC is already initialized from
;eWoz.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Rockwell 6501/6511 Equates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SCCR		= $15		;Serial Communications Control Register
SCSR		= $16		;Serial Communications Status Register
SCDAT		= $17		;Serial Channel Data Register

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ASCII Equates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NULL		= $00
CTRLC		= $03
LF		= $0A
CR		= $0D

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Miscellaneous Equates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CANCEL		= CTRLC		;ASCII code to use for cancelling current line
				;Default is CTRL+C
NEXTLOC		= CR		;Keystroke for next location in E
				;Defaults to CR

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Zero Page Storage
;
;The Rockwell R6501 and R6511 are 6502 core, but zero page
;has some differences:
;
; * RAM starts at 0x0040, internal to CPU
; * Stack located in zero page
; * I/O and control registers in zero page below 0x0040
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ADRLO		= $52		;Low address byte from GETADR
ADRHI		= $53		;High address byte from GETADR
NIBLO		= $54		;Low nybble for ASCII to hex conversion
ENDLO		= $55		;Low address byte for two-address commands
ENDHI		= $56		;High address byte for two-address commands
CKSUM		= $57		;Checksum storage for Intel HEX loader
TEMP		= $5F		;Temporary storage

	.org	$1000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;VECTORS -- Jump Table Vectors
;
;These vectors are consistent across all versions of
;GWMON-65
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
JMPTAB:	JMP	SETUP		;Cold start, initializes hardware
	JMP	WSTART		;Warm start
	JMP	COUT		;Output A register to console
	JMP	CIN		;Input A register from console, waits

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;SETUP -- Prepare hardware, print monitor sign-on message
;
;Falls through to WSTART.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SETUP:	SEI			;Disable interrupts
	CLD			;Clear decimal arithmetic mode.
	LDX	#$FF		;Set up stack pointer
	TXS

	LDY	#SIGNON		;Y = offset to SIGNON string
	JSR	PRTCLS		;Print signon message

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;WSTART -- Warm start the monitor
;
;Falls through to the command processor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WSTART:	LDX	#$FF		;Reload stack pointer since
	TXS			;we may have CANCELed

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CMDLP -- Small command processor loop
;
;Get a character from the console device and immediately
;hande it by passing off to helper function.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CMDLP:	LDA	#>WSTART	;Prime stack for RTS
	PHA
	LDA	#<WSTART-1	;Remember to decrement low byte!
	PHA

	LDY	#PROMPT		;Y = offset to PROMPT string
	JSR	PRTCLS		;Print command prompt
	JSR	CIN
	ORA	#$20		;Downcase input

	LDY	#$FF		;Index before start of CMDTAB
CMDLP1:	INY			;Point to next command char
	CMP	CMDTAB, Y
	BEQ	RUNCMD		;Equal, handle it
	LDX	CMDTAB, Y
	BEQ	ERROR		;CMDTAB null terminator, error
	INY			;Not done with CMDTAB, get past the
	INY			;command handler address
	JMP	CMDLP1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ERROR -- Print generic error message and abort
;
;Falls through to PRTERR.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ERROR:	LDY	#ERRSTR		;Y = offset to ERRSTR string

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTERR -- Print a null-terminated error string
;
;pre: STRLO, STRHI point to a null-terminated string
;post: string at STRLO, STRHI printed to console
;post: program execution returned to command loop   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTERR:	JSR	PRTCLS
	JMP	WSTART

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RUNCMD -- Run a command handler from CMDTAB
;
;pre: Y contains index into CMDTAB to command letter
;post: control transferred to command handler
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RUNCMD:	JSR	PRTSPC
	INY
	LDA	CMDTAB, Y
	STA	ADRLO
	INY
	LDA	CMDTAB, Y
	STA	ADRHI
	JMP	(ADRLO)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GETADR -- Get a 16-bit address from the console
;
;pre: none
;post: ADRLO and ADRHI contain address from console
;post: A register contains ADRLO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GETADR:	JSR	GETHEX
	STA	ADRHI
	JSR	GETHEX
	STA	ADRLO
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GETHEX -- Get byte from console as hex
;
;Enter at GETHE2 with character in A register from EDTCMD.
;
;pre: none
;post: A register contains byte from hex input
;post: Carry flag set if non hex character received
;post: Z flag set if byte is 0x00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GETHEX:	JSR	CIN		;Get high ASCII nybble
GETHE2:	PHA			;Save high nybble on stack
	JSR	CIN		;Get low ASCII nybble
	STA	NIBLO
	PLA			;A = high nybble
	JSR	HEXBYT
	BCS	GETHE3
	RTS
GETHE3:	JMP	ERROR

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HEXBYT -- Convert pair of ASCII characters to byte
;
;Destroys contents of TEMP.
;
;pre: A register contains ASCII coded high nybble
;pre: NIBLO regsiter contains ASCII coded low nybble
;post: A register contains converted byte
;post: CY flag set if non-hex character input
;post: Z flag set if conversion results in 0x00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HEXBYT:	JSR	ASCHEX
	BCS	HEXBY3		;CY set, invalid hex
HEXBY1:	ASL			;Move high nybble up
	ASL
	ASL
	ASL
	STA	TEMP
	LDA	NIBLO
	JSR	ASCHEX
	BCS	HEXBY3		;CY set, invalid hex
HEXBY2:	ORA	TEMP		;OR in high nybble
HEXBY3:	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ASCHEX -- Convert ASCII character to hex nybble
;
;pre: A register contains ASCII coded nybble
;post: A register contains nybble
;post: CY flag set if ASCII character is invalid hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ASCHEX:	SEC
	SBC	#'0'		;ASCII to decimal bias
	BCS	ASCHE1
	SEC			;Error, less than '0', done
	RTS
ASCHE1:	CMP	#$0A
	BCS	ASCHE2
	RTS			;0x0 - 0x9, done
ASCHE2:	AND	#$5F		;Upcase
	SEC
	SBC	#$07		;ASCII to hex bias
	CMP	#$10
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HEXDMP -- Hex dump memory to console
;
;This routine prints the contents of memory starting at
;ADRLO, ADRHI and ending at ENDLO, ENDHI in 16-byte blocks.
;
;pre: ADRLO, ADRHI contains starting address
;pre: ENDLO, ENDHI register pair contains ending address
;post: contents of memory printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HEXDMP:	LDA	#$00		;Initialize TEMP as completion flag
	STA	TEMP
HEXDM1:	JSR	PRTADR
	LDX	#16		;X = line loop counter
HEXDM2:	JSR	PRTSPC
	JSR	DMPLOC

	LDA	ADRLO		;Compare addresses, see if we just
	CMP	ENDLO		;printed the ending location
	BNE	HEXDM3		;Not done, dump more
	LDA	ADRHI		;Low bytes the same, check high bytes
	CMP	ENDHI
	BNE	HEXDM3		;Not done, dump more
	DEC	TEMP		;TEMP = nonzero, done

HEXDM3:	INC	ADRLO		;Increment the current dump location
	BNE	HEXDM4
	INC	ADRHI
HEXDM4:	DEX			;Decrement line loop counter
	BNE	HEXDM2		;Not zero, print more on this line

	LDA	TEMP		;Get completion flag
	BEQ	HEXDM1		;Haven't hit ENDLO, ENDHI yet, do more
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTADR -- Print an address to the console
;
;Prints CR, LF, 16-bit address, a space, and a colon. 
;Destroys A register contents.
;
;Returns through COUT.
;
;pre: ADRLO, ADRHI contains address to print
;post: address printed to console as hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTADR: JSR	CRLF
	LDA	ADRHI
	JSR	PRTHEX
	LDA	ADRLO
	JSR	PRTHEX
	LDA	#':'
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DMPLOC -- Print a byte at HL to console
;
;Destroys A and Y register contents.
;
;Falls through to PRTHEX.
;
;pre: ADRLO, ADRHI contains address of byte
;post: byte printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DMPLOC:	LDY	#$00
	LDA	(ADRLO), Y

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTHEX -- Output byte to console as hex
;
;Falls through to PRTNIB.
;
;pre: A register contains byte to be output
;post: byte is output to console as hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTHEX: PHA			;Save A register on stack
	LSR			;Rotate high nybble down
	LSR
	LSR
	LSR
	JSR	PRTNIB		;Print high nybble
	PLA			;Restore A register

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTNIB -- Print hex nybble on console
;
;Returns through COUT.
;
;pre: A register contains nybble
;post: nybble printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTNIB:	AND	#$0F
	ORA	#'0'		;Add ASCII bias
	CMP	#':'		;0x0 - 0x9?
	BCC	PRTNI1
	ADC	#$06		;Add hex bias
PRTNI1:	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HDCMD -- Hex dump command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HDCMD:	JSR	GETADR		;ADRLO, ADRHI = start address
	TAX			;X = low start address
	LDY	ADRHI		;Y = high start address
	JSR	PRTSPC
	JSR	GETADR		;ADRLO, ADRHI = end address
	STA	ENDLO		;Move them to ENDLO, ENDHI
	LDA	ADRHI
	STA	ENDHI
	STX	ADRLO		;ADRLO, ADRHI = start address
	STY	ADRHI
	JMP	HEXDMP		;Return through HEXDMP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;EDTCMD -- Edit memory command
;
;Note that this routine depends on DMPLOC clearing Y to 0x00
;
;Breaks out to main command loop through GETHEX jump to
;WSTART.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EDTCMD:	JSR	GETADR		;HL = address to open
EDTCM1:	JSR	PRTADR		;Print location address
	JSR	PRTSPC
	JSR	DMPLOC		;Print contents of location
	JSR	PRTSPC
	JSR	CIN		;Get user input
	CMP	#NEXTLOC	;Check for NEXTLOC character
	BEQ	EDTCM2		;Yes, go to next location
	JSR	GETHE2		;No, process as hex input
	STA	(ADRLO), Y
	JSR	PRTSPC
	JSR	DMPLOC		;Print contents of location (verification)
EDTCM2:	INC	ADRLO
	BNE	EDTCM1
	INC	ADRHI
	JMP	EDTCM1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GOCMD -- Call out to a specified address
;
;The stack is primed with the GWMON-65 warm start address.
;Called program can return control to GWMON-65 through a 
;RTS as long as the stack is not disturbed.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOCMD:	JSR	GETADR		;ADRLO, ADRHI = address to call
	JMP	(ADRLO)		;Jump indirect to address read

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;LODCMD -- Load an Intel HEX file from console
;
;This loader accepts data with both CR (*NIX) and
;CR,LF (DOS/Windows) terminated lines.
;
;Intel HEX record may be ended with:
;
;   * DATA (0x00) record with length of 0
;   * Any nonzero record type
;
;post: Intel HEX file loaded, or error printed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LODCMD:	JSR	CRLF
LODCM1:	JSR	CINNE
	CMP	#':'
	BNE	LODCM1		;Wait for start colon
	JSR	COUT		;Print start colon
	JSR	GETHEX		;Get record length
	BEQ	LODCM4		;Length == 0, done

	TAX			;Record length in X
	STA	CKSUM		;Start checksumming in CKSUM

	JSR	GETADR		;ADRLO, ADRHI = 16-bit starting address
	ADC	CKSUM		;Checksum low address
	ADC	ADRHI		;Checksum high address
	STA	CKSUM		;Save CKSUM

	JSR	GETHEX		;Get record type
	BNE	LODCM4		;Not Record Type 00 (DATA), done
	ADC	CKSUM
	STA	CKSUM		;Checksum record type

	LDY	#$00		;Initialize Y index
LODCM2:	JSR	GETHEX		;This is the main record processing loop
	STA	(ADRLO), Y	;Store byte
	ADC	CKSUM
	STA	CKSUM		;Checksum data byte
	INY			;Move memory pointer up
	DEX			;Decrement record length counter
	BNE	LODCM2		;Not done with the line
LODCM3:	JSR	GETHEX		;Get checksum byte
	ADC	CKSUM
	BNE	CSUMER		;Checksum bad, print error
	BEQ	LODCMD		;Process more records
LODCM4:	JSR	CIN		;Done getting data, eat chars
	CMP	#LF
	BNE	LODCM4		;No LF, keep eating
	RTS			;Got LF, return to command loop
CSUMER:	LDY	#CSERR		;Y = offset to CKSUM ERR string
	JMP	PRTERR		;PRTERR will warm start

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CMDTAB -- Table/array of commands
;
;Table entry structure:
;    * Single command character, lowercase only
;    * Pointer to implementation routine
;
;The last entry should contain 0x00 for the command char and
;no additional address.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CMDTAB:	.byte	'd'
	.word	HDCMD
	.byte	'e'
	.word	EDTCMD
	.byte	'g'
	.word	GOCMD
	.byte	'l'
	.word	LODCMD
	.byte	NULL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CIN -- Get a char from the console and echo
;
;Returns through COUT.
;
;pre: console device is initialized
;post: received char is in A register
;post: received char is echoed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CIN:	JSR	CINNE
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CINNE -- Get a character from the console, no echo
;
;Blocks until a character is available. Warm starts the
;monitor if the received character is the CANCEL char.
;
;pre: serial UART initialized
;post: A register contains received character
;post: monitor warm started if CANCEL received
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CINNE:	LDA	SCSR		;See if we got an incoming char
	LSR			;Test bit 0
	BCC	CINNE		;Wait for character
	LDA	SCDAT		;Load char
	CMP	#CANCEL		;CANCEL ASCII code?
	BNE	CINN1		;No, return
	JMP	WSTART		;Yes, warm start	
CINN1:	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;COUT -- Print a character to the console
;
;Strips parity, preserves A register.
;
;pre: A register contains character to print
;post: character printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COUT:	PHA			;Save A register
COUT1:	LDA	SCSR		;Get UART status
	AND	#$40		;Mask off XMTR Data Reg Empty
	BEQ	COUT1		;Transmitter busy, wait
	PLA			;A = character to print
	PHA			;Back on stack
	AND	#$7F		;Strip high bit
	STA	SCDAT		;Send it to UART
	PLA			;A = original character to send
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTSPC -- Print a space to the console
;
;Returns through COUT.
;
;pre: none
;post: ASCII space printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTSPC:	LDA	#' '
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CRLF -- Print a CR, LF
;
;Returns through COUT.
;
;pre: none
;post: CR, LF printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CRLF:	LDA	#CR
	JSR	COUT
	LDA	#LF
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTCLS -- Print CR, LF, and a high bit terminated string
;
;Falls through to PRTSTR
;
;pre: HL contains pointer to start of string
;post: CR, LF, and string at HL printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTCLS:	JSR	CRLF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTSTR -- Print a high bit terminated string
;
;Destroys contents of Y register.
;
;pre: Y register contains offset into STRNGS of string to be
;     printed
;post: string printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTSTR:	INY			;Point to start of string
	LDA	STRNGS, Y	;A = next char in string
	JSR	COUT
	BPL	PRTSTR		;Done if high bit is set
	RTS 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Message Strings
;
;These strings are indexed by the labels following STRNGS.
;These indexes may be fed into PRTSTR, PRTCLS, or PRTERR in
;the Y register.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STRNGS		= *
SIGNON		= ^(* - STRNGS - 1)
	.byte	"GWMON-65 0.1 S" ,'M' + $80

PROMPT		= * - STRNGS - 1
	.byte	LF, '>' + $80

CSERR		= * - STRNGS - 1
	.byte	"CKSUM "

ERRSTR		= * - STRNGS - 1
	.byte	"ERRO", 'R' + $80
