;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Glitch Works Monitor for 6502 and Compatibles
;
;Customized for Glitch Works R65X1Q SBC. This is development
;code and expects the R65X1Q SBC is already initialized from
;eWoz.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Rockwell 6501/6511 Equates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SCCR		= $15		;Serial Communications Control Register
SCSR		= $16		;Serial Communications Status Register
SCDAT		= $17		;Serial Channel Data Register

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ASCII Equates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NULL		= $00
CTRLC		= $03
LF		= $0A
CR		= $0D

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Miscellaneous Equates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CANCEL		= CTRLC		;ASCII code to use for cancelling current line
				;Default is CTRL+C
NEXTLOC		= CR		;Keystroke for next location in E
				;Defaults to CR

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Zero Page Storage
;
;The Rockwell R6501 and R6511 are 6502 core, but zero page
;has some differences:
;
; * RAM starts at 0x0040, internal to CPU
; * Stack located in zero page
; * I/O and control registers in zero page below 0x0040
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STRLO		= $50		;Low string pointer for PRTSTR
STRHI		= $51		;High string point for PRTSTR
ADRLO		= $52		;Low address byte from GETADR
ADRHI		= $53		;High address byte from GETADR
NIBLO		= $54		;Low nybble for ASCII to hex conversion
NIBHI		= $55		;High nybble for ASCII to hex conversion
ENDLO		= $56		;Low address byte for two-address commands
ENDHI		= $57		;High address byte for two-address commands
TEMP		= $5F		;Temporary storage

	.org	$1000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;VECTORS -- Jump Table Vectors
;
;These vectors are consistent across all versions of
;GWMON-65
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
JMPTAB:	JMP	SETUP		;Cold start, initializes hardware
	JMP	WSTART		;Warm start
	JMP	COUT		;Output A register to console
	JMP	CIN		;Input A register from console, waits

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;SETUP -- Prepare hardware, print monitor sign-on message
;
;Falls through to WSTART.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SETUP:	SEI			;Disable interrupts
	CLD			;Clear decimal arithmetic mode.
	LDX	#$FF		;Set up stack pointer
	TXS

	LDA	#<SIGNON	;Set up pointers to signon message
	STA	STRLO
	LDA	#>SIGNON
	STA	STRHI
	JSR	PRTCLS		;Print signon message

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;WSTART -- War start the monitor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WSTART:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CMDLP -- Small command processor loop
;
;Get a character from the console device and immediately
;hande it by passing off to helper function.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CMDLP:	LDA	#>WSTART	;Prime stack for RTS
	PHA
	LDA	#<WSTART-1	;Remember to decrement low byte!
	PHA
	LDA	#<PROMPT	;Set up pointers to command prompt
	STA	STRLO
	LDA	#>PROMPT
	STA	STRHI
	JSR	PRTCLS		;Print command prompt
	JSR	CIN
	ORA	#$20		;Downcase input

	LDY	#$FF		;Index before start of CMDTAB
CMDLP1:	INY			;Point to next command char
	CMP	CMDTAB, Y
	BEQ	RUNCMD
	PHA			;Save command letter
	LDA	CMDTAB, Y
	BEQ	ERROR		;CMDTAB null terminator, error
	PLA			;Restore command letter
	INY			;Get past handler address
	INY
	JMP	CMDLP1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ERROR -- Print generic error message and abort
;
;Falls through to PRTERR.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ERROR:	LDA	#<ERRSTR
	STA	STRLO
	LDA	#>ERRSTR
	STA	STRHI

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTERR -- Print a null-terminated error string
;
;pre: STRLO, STRHI point to a null-terminated string
;post: string at STRLO, STRHI printed to console
;post: program execution returned to command loop   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTERR:	JSR	PRTCLS
	JMP	WSTART

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RUNCMD -- Run a command handler from CMDTAB
;
;pre: Y contains index into CMDTAB to command letter
;post: control transferred to command handler
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RUNCMD:	JSR	PRTSPC
	INY
	LDA	CMDTAB, Y
	STA	ADRLO
	INY
	LDA	CMDTAB, Y
	STA	ADRHI
	JMP	(ADRLO)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GETADR -- Get a 16-bit address from the console
;
;pre: none
;post: ADRLO and ADRHI contain address from console
;post: A register contains ADRLO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GETADR:	JSR	GETHEX
	STA	ADRHI
	JSR	GETHEX
	STA	ADRLO
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GETHEX -- Get byte from console as hex
;
;Enter at GETHE2 with character in A register from EDTCMD.
;
;pre: none
;post: A register contains byte from hex input
;post: Carry flag set if non hex character received
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GETHEX:	JSR	CIN
GETHE2:	STA	NIBHI
	JSR	CIN
	STA	NIBLO
	JSR	HEXBYT
	BCS	GETHE3
	RTS
GETHE3:	JMP	ERROR

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HEXBYT -- Convert pair of ASCII characters to byte
;
;Destroys contents of TEMP.
;
;pre: NIBHI and NIBLO contain ASCII coded chars to convert
;post: A register contains converted byte
;post: CY flag set if non-hex character input
;post: Z flag set if conversion results in 0x00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HEXBYT:	LDA	NIBHI
	JSR	ASCHEX
	BCC	HEXBY1
	RTS
HEXBY1:	ASL
	ASL
	ASL
	ASL
	STA	TEMP
	LDA	NIBLO
	JSR	ASCHEX
	BCC	HEXBY2
	RTS
HEXBY2:	ORA	TEMP
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ASCHEX -- Convert ASCII character to hex nybble
;
;pre: A register contains ASCII coded nybble
;post: A register contains nybble
;post: CY flag set if ASCII character is invalid hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ASCHEX:	SEC
	SBC	#'0'		;ASCII to decimal bias
	BCS	ASCHE1
	SEC			;Error, less than '0', done
	RTS
ASCHE1:	CMP	#$0A
	BCS	ASCHE2
	RTS			;0x0 - 0x9, done
ASCHE2:	AND	#$5F		;Upcase
	SEC
	SBC	#$07		;ASCII to hex bias
	CMP	#$10
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HEXDMP -- Hex dump memory to console
;
;This routine prints the contents of memory starting at
;ADRLO, ADRHI and ending at ENDLO, ENDHI in 16-byte blocks.
;
;pre: ADRLO, ADRHI contains starting address
;pre: ENDLO, ENDHI register pair contains ending address
;post: contents of memory printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HEXDMP:	LDA	#$00		;Initialize TEMP as completion flag
	STA	TEMP
HEXDM1:	JSR	CRLF
	JSR	PRTADR
	LDX	#16		;X = line loop counter
HEXDM2:	JSR	PRTSPC
	JSR	DMPLOC

	LDA	ADRLO		;Compare addresses, see if we just
	CMP	ENDLO		;printed the ending location
	BNE	HEXDM3		;Not done, dump more
	LDA	ADRHI		;Low bytes the same, check high bytes
	CMP	ENDHI
	BNE	HEXDM3		;Not done, dump more
	DEC	TEMP		;TEMP = nonzero, done

HEXDM3:	INC	ADRLO		;Increment the current dump location
	BNE	HEXDM4
	INC	ADRHI
HEXDM4:	DEX			;Decrement line loop counter
	BNE	HEXDM2		;Not zero, print more on this line

	LDA	TEMP		;Get completion flag
	BEQ	HEXDM1		;Haven't hit ENDLO, ENDHI yet, do more
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTADR -- Print an address to the console
;
;Prints a 16-bit address, a space, and a colon. Destroys
;A register contents.
;
;Returns through COUT.
;
;pre: ADRLO, ADRHI contains address to print
;post: address printed to console as hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTADR: LDA	ADRHI
	JSR	PRTHEX
	LDA	ADRLO
	JSR	PRTHEX
	LDA	#':'
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DMPLOC -- Print a byte at HL to console
;
;Destroys A and Y register contents.
;
;Falls through to PRTHEX.
;
;pre: ADRLO, ADRHI contains address of byte
;post: byte printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DMPLOC:	LDY	#$00
	LDA	(ADRLO), Y

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTHEX -- Output byte to console as hex
;
;Falls through to PRTNIB.
;
;pre: A register contains byte to be output
;post: byte is output to console as hex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTHEX: PHA			;Save A register on stack
	LSR			;Rotate high nybble down
	LSR
	LSR
	LSR
	JSR	PRTNIB		;Print high nybble
	PLA			;Restore A register

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTNIB -- Print hex nybble on console
;
;Returns through COUT.
;
;pre: A register contains nybble
;post: nybble printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTNIB:	AND	#$0F
	ORA	#'0'		;Add ASCII bias
	CMP	#':'		;0x0 - 0x9?
	BCC	COUT
	ADC	#$06		;Add hex bias
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;HDCMD -- Hex dump command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HDCMD:	JSR	GETADR		;ADRLO, ADRHI = start address
	TAX			;X = low start address
	LDY	ADRHI		;Y = high start address
	JSR	PRTSPC
	JSR	GETADR		;ADRLO, ADRHI = end address
	STA	ENDLO		;Move them to ENDLO, ENDHI
	LDA	ADRHI
	STA	ENDHI
	STX	ADRLO		;ADRLO, ADRHI = start address
	STY	ADRHI
	JMP	HEXDMP		;Return through HEXDMP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;EDTCMD -- Edit memory command
;
;Note that this routine depends on DMPLOC clearing Y to 0x00
;
;Breaks out to main command loop through GETHEX jump to
;WSTART.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EDTCMD:	JSR	GETADR		;HL = address to open
EDTCM1:	JSR	CRLF
	JSR	PRTADR		;Print location address
	JSR	PRTSPC
	JSR	DMPLOC		;Print contents of location
	JSR	PRTSPC
	JSR	CIN		;Get user input
	CMP	#NEXTLOC	;Check for NEXTLOC character
	BEQ	EDTCM2		;Yes, go to next location
	JSR	GETHE2		;No, process as hex input
	STA	(ADRLO), Y
	JSR	PRTSPC
	JSR	DMPLOC		;Print contents of location (verification)
EDTCM2:	INC	ADRLO
	BNE	EDTCM1
	INC	ADRHI
	JMP	EDTCM1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GOCMD -- Call out to a specified address
;
;The stack is primed with the GWMON-65 warm start address.
;Called program can return control to GWMON-65 through a 
;RTS as long as the stack is not disturbed.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOCMD:	JSR	GETADR		;ADRLO, ADRHI = address to call
	JMP	(ADRLO)		;Jump indirect to address read

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CMDTAB -- Table/array of commands
;
;Table entry structure:
;    * Single command character, lowercase only
;    * Pointer to implementation routine
;
;The last entry should contain 0x00 for the command char and
;no additional address.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CMDTAB:	.byte	'd'
	.word	HDCMD
	.byte	'e'
	.word	EDTCMD
	.byte	'g'
	.word	GOCMD
	.byte	$00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CIN -- Get a character from the console and echo
;
;Blocks until a character is available. Warm starts the
;monitor if the received character is the CANCEL char.
;
;Falls through to COUT if the character received is not the
;CANCEL character.
;
;pre: serial UART initialized
;post: character is echoed to the console
;post: A register contains received character
;post: monitor warm started if CANCEL received
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CIN:	LDA	SCSR		;See if we got an incoming char
	AND	#$01		;Test bit 0
	BEQ	CIN		;Wait for character
	LDA	SCDAT		;Load char
	CMP	#CANCEL		;CANCEL ASCII code?
	BNE	COUT		;No, echo and return
	JMP	WSTART		;Yes, warm start	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;COUT -- Print a character to the console
;
;Strips parity, preserves A register.
;
;pre: A register contains character to print
;post: character printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COUT:	PHA			;Save A register
COUT1:	LDA	SCSR		;Get UART status
	AND	#$40		;Mask off XMTR Data Reg Empty
	BEQ	COUT1		;Transmitter busy, wait
	PLA			;A = character to print
	PHA			;Back on stack
	STA	SCDAT		;Send it to UART
	PLA			;A = original character to send
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTSPC -- Print a space to the console
;
;Returns through COUT.
;
;pre: none
;post: ASCII space printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTSPC:	LDA	#' '
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;CRLF -- Print a CR, LF
;
;Returns through COUT.
;
;pre: none
;post: CR, LF printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CRLF:	LDA	#CR
	JSR	COUT
	LDA	#LF
	JMP	COUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTCLS -- Print CR, LF, and a high bit terminated string
;
;Falls through to PRTSTR
;
;pre: HL contains pointer to start of string
;post: CR, LF, and string at HL printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTCLS:	JSR	CRLF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRTSTR -- Print a high bit terminated string
;
;Destroys contents of Y register.
;
;pre: STRLO, STRHI point to NULL terminated string
;post: string printed to console
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRTSTR:	LDY	#$FF		;Clear string position counter
PRTST1:	INY
	LDA	(STRLO), Y	;A = next char in string
	AND	#$7F		;Strip terminating bit
	JSR	COUT
	LDA	(STRLO), Y
	BPL	PRTST1
	RTS 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Message Strings
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SIGNON:	.byte	"GWMON-65 0.1 S" ,'M' + $80
PROMPT:	.byte	LF, '>' + $80
ERRSTR:	.byte	"ERRO", 'R' + $80
